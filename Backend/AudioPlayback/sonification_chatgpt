import sys
import os
import time
import logging
from datetime import datetime
import numpy as np
import fluidsynth
from mido import Message, MidiFile, MidiTrack

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Add necessary paths
try:
    backend_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
    market_path = os.path.join(backend_path, 'Market')
    sys.path.extend([backend_path, market_path])
    from Market.MarketDataDisplayScript_Optimized import main_ohlcv
except ImportError as e:
    logger.error(f"Failed to import required modules: {e}")
    sys.exit(1)

beat_pattern = [1, 0.5, 0.5, 0.5, 0.5, 1, 0.5, 0.5]

# Audio constants
SAMPLE_RATE = 44100
CHANNELS = 1
MIN_FREQ = 60  # C4
MAX_FREQ = 84  # C6
BEAT_DURATION = 0.25  # Quarter note at 120 BPM

# Initialize FluidSynth
fs = fluidsynth.Synth()
fs.start(driver='coreaudio')  # Use 'alsa' for Linux, 'coreaudio' for macOS, or 'dsound' for Windows
sfid = fs.sfload("/Users/udaikhattar/Desktop/Development/AudioSpy/Steinway_D__SC55_Style_.sf2")
fs.program_select(0, sfid, 0, 0)  # Select a piano sound

class AudioPlayer:
    """Handles real-time audio playback."""

    def play(self, melody_note, duration, melody_velocity, chord_notes, chord_velocity, harmony_note, harmony_velocity):
        """Play notes using FluidSynth."""
        try:
            fs.noteon(0, melody_note, melody_velocity)
            for note in chord_notes:
                fs.noteon(0, note, chord_velocity)
            if harmony_note is not None:
                fs.noteon(0, harmony_note, harmony_velocity)

            time.sleep(duration)

            fs.noteoff(0, melody_note)
            for note in chord_notes:
                fs.noteoff(0, note)
            if harmony_note is not None:
                fs.noteoff(0, harmony_note)
        except Exception as e:
            logger.error(f"Error playing audio: {e}")

    def close(self):
        """Close FluidSynth."""
        fs.delete()

def normalize_value(value, min_val, max_val):
    """Normalize a value to the range [0, 1]."""
    return (value - min_val) / (max_val - min_val) if max_val > min_val else 0

def map_to_note(normalized_value, min_note, max_note):
    """Map a normalized value to a MIDI note range."""
    return int(min_note + normalized_value * (max_note - min_note))

def sonify_data(data, beat_index):
    """Convert market data to audio based on sonification rules."""
    try:
        # Price change to note (Chapter 2: Polarity)
        price_change = (data['close'] - data['open']) / data['open'] if data['open'] != 0 else 0
        norm_price_change = normalize_value(price_change, -0.05, 0.05)  # Assume max 5% change
        melody_note = map_to_note(norm_price_change, MIN_FREQ, MAX_FREQ)

        # Volume to velocity (Chapter 15: Scaling)
        norm_volume = normalize_value(data['volume'], 0, data['volume'] * 2)  # Dynamic scaling
        melody_velocity = int(norm_volume * 40 + 60)  # Ensure some minimal velocity

        # Create a simple and consistent beat pattern
        beat_pattern = [1, 0.5, 0.5, 0.5, 0.5, 1, 0.5, 0.5]
        duration = beat_pattern[beat_index] * BEAT_DURATION

        # Map RSI to chord (Chapter 3: Stream-based Sonification)
        if data['rsi'] is not None:
            if data['rsi'] > 70:
                chord_notes = [melody_note, melody_note + 4, melody_note + 7]  # Major chord
            elif data['rsi'] < 30:
                chord_notes = [melody_note, melody_note + 3, melody_note + 7]  # Minor chord
            else:
                chord_notes = [melody_note]  # No chord, just the melody note
            chord_velocity = int(melody_velocity * 0.7)  # Softer chord velocity
        else:
            chord_notes = []
            chord_velocity = 0

        # Map Ichimoku Cloud to harmony (Chapter 3: Stream-based Sonification)
        if data['ichimoku_cloud_leading_fast_line'] is not None and data['ichimoku_cloud_leading_slow_line'] is not None:
            if data['ichimoku_cloud_leading_fast_line'] > data['ichimoku_cloud_leading_slow_line']:
                harmony_note = melody_note + 2  # Harmony above the melody
            else:
                harmony_note = melody_note - 2  # Harmony below the melody
            harmony_velocity = int(melody_velocity * 0.6)  # Softer harmony velocity
        else:
            harmony_note = None
            harmony_velocity = 0

        return melody_note, duration, melody_velocity, chord_notes, chord_velocity, harmony_note, harmony_velocity
    except Exception as e:
        logger.error(f"Error in sonify_data: {e}")
        return None, None, None, [], None, None, None

def save_midi(filename, notes):
    """Save notes to a MIDI file."""
    try:
        mid = MidiFile()
        track = MidiTrack()
        mid.tracks.append(track)

        track.append(Message('program_change', program=0, time=0))  # Piano sound

        current_time = 0
        for melody_note, duration, melody_velocity, chord_notes, chord_velocity, harmony_note, harmony_velocity in notes:
            ticks_duration = int(duration * mid.ticks_per_beat)
            track.append(Message('note_on', note=melody_note, velocity=melody_velocity, time=current_time))
            for note in chord_notes:
                track.append(Message('note_on', note=note, velocity=chord_velocity, time=current_time))
            if harmony_note is not None:
                track.append(Message('note_on', note=harmony_note, velocity=harmony_velocity, time=current_time))

            track.append(Message('note_off', note=melody_note, velocity=0, time=ticks_duration))
            for note in chord_notes:
                track.append(Message('note_off', note=note, velocity=0, time=ticks_duration))
            if harmony_note is not None:
                track.append(Message('note_off', note=harmony_note, velocity=0, time=ticks_duration))

            current_time = 0  # Reset time after each event

        mid.save(filename)
        logger.info(f"MIDI file saved to {filename}")
    except Exception as e:
        logger.error(f"Error saving MIDI: {e}")

def format_value(value):
    """Format a value for logging, handling None values."""
    return f"{value:.2f}" if value is not None else "N/A"

def main():
    """Main function to run the sonification process."""
    audio_player = AudioPlayer()
    beat_index = 0
    start_time = None
    notes = []

    try:
        for data in main_ohlcv():
            if start_time is None:
                start_time = datetime.fromtimestamp(data['timestamp'] / 1e9)
            
            current_time = datetime.fromtimestamp(data['timestamp'] / 1e9)
            elapsed_time = current_time - start_time
            
            # Simulate real-time playback
            time.sleep(max(0, elapsed_time.total_seconds() - (datetime.now() - start_time).total_seconds()))

            melody_note, duration, melody_velocity, chord_notes, chord_velocity, harmony_note, harmony_velocity = sonify_data(data, beat_index)
            if melody_note is not None:
                audio_player.play(melody_note, duration, melody_velocity, chord_notes, chord_velocity, harmony_note, harmony_velocity)
                notes.append((melody_note, duration, melody_velocity, chord_notes, chord_velocity, harmony_note, harmony_velocity))

            beat_index = (beat_index + 1) % len(beat_pattern)

            # Log market data and indicators
            logger.info(f"Timestamp: {current_time}, Close: {format_value(data['close'])}, Volume: {data['volume']}")
            logger.info(f"EMA9: {format_value(data['ema_9'])}, EMA26: {format_value(data['ema_26'])}, EMA52: {format_value(data['ema_52'])}")
            logger.info(f"RSI: {format_value(data['rsi'])}, ATR: {format_value(data['atr'])}")
            logger.info("Ichimoku Cloud:")
            logger.info(f"  Base Line: {format_value(data['ichimoku_base_line'])}")
            logger.info(f"  Conversion Line: {format_value(data['ichimoku_conversion_line'])}")
            logger.info(f"  Lagging Line: {format_value(data['ichimoku_lagging_line'])}")
            logger.info(f"  Leading Fast Line: {format_value(data['ichimoku_cloud_leading_fast_line'])}")
            logger.info(f"  Leading Slow Line: {format_value(data['ichimoku_cloud_leading_slow_line'])}")
            logger.info("-" * 50)

    except KeyboardInterrupt:
        logger.info("Stopping playback...")
    except Exception as e:
        logger.error(f"An error occurred: {e}")
    finally:
        audio_player.close()
        save_midi("market_sonification.mid", notes)

if __name__ == "__main__":
    main()